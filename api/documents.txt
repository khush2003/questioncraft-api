Page Content: $$( NTRODUCTION TO THE STREAMS AP Chonlameth ARPNIKANONDT, Ph.D.  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 61, 'chunk_length': 61, 'page_number': 1} )$$ 

Page Content: $$( Lambdas, streams, functional and reactive programming Modern Java Our MAIN text >>> INACTION Raoul-Gabriel Urma Mario Fusco Alan Mycroft We also rely on other sources for additional information. MANNING  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 203, 'chunk_length': 203, 'page_number': 2} )$$ 

Page Content: $$( Before (Java 7) ()<>)sTlAeniy Mau = SaysTg?Tgoenmo[ <ysTg>}stI Filters the elements for(Dish dish: menu) . using an accumulator if(dish.getCalories() < 400) { lowCaloricDishes.add(dish) ;. Sorts the dishes with an anonymous class Collections.sort(lowCaloricDishes, new Comparator<Dish>() {  public int compare(Dish dishl, Dish dish2) { return Integer.compare(dishl.getCalories() , dish2.getCalories()) ; !{ Processes the List<String> lowCaloricDishesName = new ArrayList<>() ; sorted list to select for(Dish dish: lowcaloricDishes)  the names of dishes lowCaloricDishesName.add(dish.getName() ) ; 3  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 599, 'chunk_length': 599, 'page_number': 3} )$$ 

Page Content: $$( lambda lambda lambda After (Java 8) filter sorted dew collect menu Selects dishes import static java.util.Comparator.comparing;. that are below import static java.util.stream.Collectors.toList; 400 calories List<String> lowCaloricDishesName  Sorts them menu.stream() by calories .filter(d -> d.getcalories() < 400) .sorted(comparing(Dish::getCalories) ) Stores all the . map(Dish: :getName) names in a List Extracts the names .collect(toList()) ; of these dishes 4  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 465, 'chunk_length': 465, 'page_number': 4} )$$ 

Page Content: $$( Or... another Streams API example Map<Dish.Type, List<Dish>> dishesByType = menu.stream() .collect(groupingBy(Dish: :getType)) ; {FISH=[prawns, salmon], OTheR-[french fries, rice, season fruit, pizza],. MEAT-[pork, beef, chicken]} To summarize, 1 the Streams API in Java 8 lets you write code that's. Declarative--More concise and readable Composable--Greater flexibility  Parallelizable--Better performance  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 408, 'chunk_length': 408, 'page_number': 5} )$$ 

Page Content: $$( public Dish(String name,. boolean vegetarian, int calories, Type type) where a Di sh is an immutable class defined as public class Dish { For the discussion.. private final String name;. private final boolean vegetarian;. private final int calories; private final Type type; public Dish(String name, boolean vegetari this.name = name; List<Dish> menu = Arrays.asList( this.vegetarian = vegetarian; new Dish("pork", false, 800, Dish.Type.MEAT), this.calories = calories;. new Dish("beef", false, 700, Dish.Type.MEAT), this.type = type; new Dish("chicken", false, 400, Dish.Type.MEAT), { public String getName() {. new Dish("french fries", true, 530, Dish.Type.OTHER), return name; new Dish("rice", true, 350, Dish.Type.OTHER), new Dish("season fruit", true, 120, Dish.Type.OTHeR), public boolean isVegetarian() { new Dish("pizza", true, 550, Dish.Type.OTHER), return vegetarian; new Dish("prawns", false, 300, Dish.Type.FIsH), { public int getCalories() { new Dish("salmon", false, 450, Dish.Type.FIsH) ); return calories; pu )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 1024, 'chunk_length': 1024, 'page_number': 6} )$$ 

Page Content: $$( HeR), public boolean isVegetarian() { new Dish("pizza", true, 550, Dish.Type.OTHER), return vegetarian; new Dish("prawns", false, 300, Dish.Type.FIsH), { public int getCalories() { new Dish("salmon", false, 450, Dish.Type.FIsH) ); return calories; public Type getType() { return type; @Override public String toString() { return name; public enum Type { MEAT, FISH, OTHER } 6  )$$  
Metadata: $$( {'chunk_index': 1, 'start_position': 774, 'end_position': 1150, 'chunk_length': 376, 'page_number': 6} )$$ 

Page Content: $$( Another quick look at Streams Gets a stream from menu (the list of dishes) import static java.util.stream.Collectors.toList; Creates a pipeline of List<String> threeHighcaloricDishNames = operations: first filter menu.stream() high-calorie dishes (00g < ()sateotegae6 ystp <- yatp)gsaesg .map(Dish: :getName) Gets the names. .limit(3) of the dishes .collect(toList()) ; System.out.println(threeHighcaloricDishNames) ;. Selects only the first three Gives results [pork, Stores the results. beef, chicken] in another List Pipelining is one defining characteristics. Any other?.  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 576, 'chunk_length': 576, 'page_number': 7} )$$ 

Page Content: $$( Menu stream Stream<Dish> filter(d -> d.getcalories() > 300) Stream<Dish> map(Dish: :getName) Stream<String> limit(3) Stream<String> collect(toList()) List<String> 8  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 165, 'chunk_length': 165, 'page_number': 8} )$$ 

Page Content: $$( Collections. A collection in Java 8 is like A stream in Java 8 is like a movie. a movie stored on DVD. streamed over the internet.. Vs Eager construction means Lazy construction means Streams waiting for computation values are computed of ALL values. only as needed.. Internet All file data loaded from DVD Like a DVD, a collection holds all the values that Like a streaming video, values the data structure currently has--every element in are computed as they are needed.. the collection has to be computed before it. can be added to the collection. 9  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 553, 'chunk_length': 553, 'page_number': 9} )$$ 

Page Content: $$( Traversable only once.... List<String> title = Arrays.asList("Modern", "Java", "In", "Action"); Stream<String> s = title.stream() ; Prints each word in the title. s.forEach(System.out::println) ; s.forEach(System.out::println) ;  java.lang.IllegalStateException: stream has already been operated upon or closed. Keep in mind that you can consume a stream only once! 10  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 369, 'chunk_length': 369, 'page_number': 10} )$$ 

Page Content: $$( External vs Internal Iteration Listing 4.1 Collections: external iteration with a for-each loop. Explicitly iterates the list List<String> names = new ArrayList<>() ; of menu sequentially for(Dish dish: menu) { names.add(dish.getName() ; Extracts the name and adds it to an accumulator Listing 4.2 Collections: external iteration using an iterator behind the scenes List<String> names = new ArrayList<>(); Iterator<String> iterator = menu.iterator(); while(iterator.hasNext()) { Iterates Dish dish = iterator.next(); explicitly names.add(dish.getName()) ; Listing 4.3  Streams: internal iteration. List<String> names menu.stream() Parameterizes map with the .map(Dish: :getName) getName method to extract Starts executing the the name of a dish .collect(toList()); pipeline of operations; no iteration. 11  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 806, 'chunk_length': 806, 'page_number': 11} )$$ 

Page Content: $$( of operations; no iteration. 11  )$$  
Metadata: $$( {'chunk_index': 1, 'start_position': 774, 'end_position': 806, 'chunk_length': 32, 'page_number': 11} )$$ 

Page Content: $$( Based on what you learned about external iteration in listing 4.1 and 4.2, which stream operation would you use to refactor the following code?. List<String> hiqhcaloricDishes = new ArrayList<>0 ; Iterator<String> iterator = menu.iterator(); while(iterator.hasNext()) ( Dish dish = iterator.next() ; if(dish.getCalories() > 300) ( highcaloricDishes.add(d.getName() ) ; 12  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 372, 'chunk_length': 372, 'page_number': 12} )$$ 

Page Content: $$( Based on what you learned about external iteration in listing 4.1 and 4.2, which stream operation would you use to refactor the following code?. List<String> highcaloricDishes = new ArrayList<>() ; Iterator<String> iterator = menu.iterator(); while(iterator.hasNext()) ( Dish dish = iterator.next() ; if(dish.getcalories() > 300) { highCaloricDishes.add(d.getName()) ; Answer: You need to use the filter pattern List<String> highcaloricDish = menu.streamO .filter(dish -> dish.getcalories() > 300) .collect(toList()) ; 13  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 522, 'chunk_length': 522, 'page_number': 13} )$$ 

Page Content: $$( Stream Operations (1) The streams interface in java.util.stream. Stream defines many operations. They can be classified into two categories. Let's look at our previous example once again: Gets a stream from the list of dishes List<String> names = menu.stream() .filter(dish -> dish.getCalories() > 300) .map(Dish: :getName) Intermediate Intermediate .limit(3) operation operation .collect(toList()) ; Converts the Intermediate Stream into a List operation You can see two groups of operations;.  filter, map, and limit can be connected together to form a pipeline.  collect causes the pipeline to be executed and closes it.. 14  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 628, 'chunk_length': 628, 'page_number': 14} )$$ 

Page Content: $$( Stream Operations (2) lambda lambda integer filter limit menu map collect Intermediate Terminal operations operation In the stream pipeline that follows, can you identify the intermediate and terminal operations? long count = menu.stream() .filter(dish -> dish.getcalories() > 300) .distinct(). .limit(3) . count () ; 15  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 321, 'chunk_length': 321, 'page_number': 15} )$$ 

Page Content: $$( Working with Streams To summarize, working with streams in general involves three items. A data source (such as a collection) to perform a query on A chain of intermediate operations that form a stream pipeline A terminal operation that executes the stream pipeline and produces a result The idea behind a stream pipeline is similar to the builder pattern (see http://en wikipedia.org/wiki/Builder_pattern). In the builder pattern, there's a chain of calls to set up a configuration (for streams this is a chain of intermediate operations), fol- lowed by a call to a bui1d method (for streams this is a terminal operation) 16  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 626, 'chunk_length': 626, 'page_number': 16} )$$ 

Page Content: $$( Table 4.1Intermediate operations. Operation Type Return type Argument of the operation Function descriptor filter Intermediate Stream<T> Predicate<T> T -> boolean deu Intermediate Stream<R> Function<T, R> T -> R limit Intermediate Stream<T> sorted Intermediate Stream<T> Comparator<T> (T, T) -> int distinct Intermediate Stream<T> Table 4.2 Terminal operations. Operation Type Return type Purpose forEach Terminal void Consumes each element from a stream and applies a Iambda to each of them. Terminal long count Returns the number of elements in a stream.. collect Terminal (generic) Reduces the stream to create a collection such as a List, a Map, or even an Integer. See chapter 6 for. more detail. 17  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 705, 'chunk_length': 705, 'page_number': 17} )$$ 

Page Content: $$( STREAMS: FILTERING 18  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 22, 'chunk_length': 22, 'page_number': 18} )$$ 

Page Content: $$( import static java.util.stream.Collectors.toList; List<Dish> vegetarianDishes = Filtering with Predicate. menu.stream() Use a method .filter (Dish: :isVegetarian) reference to .collect(toist()) ; check if a dish is vegetarian friendly. Menu stream Stream<Dish> filter(Dish::isVegetarian) Stream<Dish> collect(toList()) List<Dish> 19  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 333, 'chunk_length': 333, 'page_number': 19} )$$ 

Page Content: $$( List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); numbers.stream() .filter(i -> i % 2 == 0) .distinct() Filtering Unique Elements .forEach(System.out::println) ;. Numbers stream Stream<Integer> filter(i -> i % 2 =-= 0) Stream<Integer> distinct() Stream<Integer> forEach(System.out: :println). System.out.println(2) ; void System.out.println(4) ; 20  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 359, 'chunk_length': 359, 'page_number': 20} )$$ 

Page Content: $$( STREAMS: SLICING (JAVA 9) 21  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 29, 'chunk_length': 29, 'page_number': 21} )$$ 

Page Content: $$( Slicing using Predicate Let's say you have the following special list of dishes: List<Dish> specialmenu = Arrays.asList( new Dish("seasonal fruit", true, 120, Dish.Type.OTheR). new Dish("prawns", false, 300, Dish.Type.FIsH), new Dish("rice", true, 350, Dish.Type.OTHER), new Dish("chicken", false, 400, Dish.Type.MEAT), new Dish("french fries", true, 530, Dish.Type.OTHeR)); List<Dish> filteredMenu = specialMenu.stream() Lists seasonal .filter(dish -> dish.getcalories( < 320) fruit, prawns. .collect(toList()) ; Issue? 22  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 524, 'chunk_length': 524, 'page_number': 22} )$$ 

Page Content: $$( Using takeWhile and dropWhile.. List<Dish> slicedMenul = specialMenu.stream() Lists seasonal .takewhile(dish -> dish.getCalories() < 320) fruit, prawns .collect(tolist()) ; List<Dish> slicedMenu2 = specialMenu.stream() Lists rice, chicken, .dropwhile(dish -> dish.getCalories() < 320) french fries .collect(toList()) ; 23  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 322, 'chunk_length': 322, 'page_number': 23} )$$ 

Page Content: $$( Truncating and Skipping. List<Dish> dishes = specialMenu .stream() .filter(dish -> dish.getcalories( > 300) Lists rice, chicken,. .limit(3) french fries .collect(toList()) ; 4 List<Dish> dishes = menu.stream() .filter(d -> d.getcalories( > 300) .skip(2) .collect(toList()) ; 24  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 278, 'chunk_length': 278, 'page_number': 24} )$$ 

Page Content: $$( Menu stream Stream<Dish> filter(d -> d.getcalories() > 300) Stream<Dish> limit(3) Stream<Dish> collect(toList () List<Dish>  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 124, 'chunk_length': 124, 'page_number': 25} )$$ 

Page Content: $$( Menu stream. Stream<Dish> filter(d -> d.qetcalories( > 300) Stream<Dish> skip(2) Stream<Dish> collect(toList ( ) List<Dish>  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 124, 'chunk_length': 124, 'page_number': 26} )$$ 

Page Content: $$( STREAMS: MAPPING (TRANSFORMING 27  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 34, 'chunk_length': 34, 'page_number': 27} )$$ 

Page Content: $$( Applying a function to each element of a stream List<String> dishNames = menu.stream() .map(Dish: :getName) .collect(tolist()) ; List<Integer> dishNameLengths = menu.stream( . map(Dish: :getName) .map(String::length) .collect(toList()) ; 28  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 241, 'chunk_length': 241, 'page_number': 28} )$$ 

Page Content: $$( Considering this... given the list of words ["Hello, " "world"] you'd like to return the list ["H, " "e, " "], " "O, " "W, " "r, " "d"]. Will this work? words.stream( .map(word -> word.split("")) .distinct0 .collect(tolist()) ; 29  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 231, 'chunk_length': 231, 'page_number': 29} )$$ 

Page Content: $$( Stream of words Hello World Stream<String> map(s -> s.split("")) Stream<String[]> H 1 1 M r 1 e 0 0 d distinct() Stream<String[]> H 1 1 e 0 M r 1 0 d collect(toList() List<String[] > H 1 1 M r 1 e 0 0 d  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 203, 'chunk_length': 203, 'page_number': 30} )$$ 

Page Content: $$( And what about this? Will this work? Converts each word into an words.stream() array of its individual letters .map(word -> word.split("")) .map(Arrays: :stream) Makes each array into .distinct() a separate stream .collect(tolist()) ; 31  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 238, 'chunk_length': 238, 'page_number': 31} )$$ 

Page Content: $$( And what about this? Will this work?. Converts each word into an words.stream() array of its individual letters .map(word -> word.split("")) .map(Arrays: :stream) Makes each array into. .distinct() a separate stream .collect(toList()) ; The current solution still doesn't work! This is because you now end up with a list of streams (more precisely, List<Stream<String>>). Indeed, you first convert each word into an array of its individual letters and then make each array into a separate stream. 32  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 500, 'chunk_length': 500, 'page_number': 32} )$$ 

Page Content: $$( Using flatMap... You can fix this problem by using f1atMap as follows: List<String> uniqueCharacters = Converts each word into an. words.stream() array of its individual letters. .map(word -> word.split("")) .flatMap(Arrays: :stream). Flattens each generated .distinct() stream into a single stream. .collect(toList()) ; 33  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 324, 'chunk_length': 324, 'page_number': 33} )$$ 

Page Content: $$( Stream of words. Hello. Stream<String> World. map(s -> s.split("")) Stream<String[] > H 0 M e d flatMap(Arrays: : stream) Stream<String> e 1 H 1 0 M 0 1 d distinct() Stream<String> e d collect(toList()) List<String> H e 0 M r 34  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 229, 'chunk_length': 229, 'page_number': 34} )$$ 

Page Content: $$( Food for thought.. 1. Given a list of numbers, how would you return a list of the square of each number? For example, given [1, 2, 3, 4, 5] you should return [1, 4, 9, 16, 25]..  35  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 182, 'chunk_length': 182, 'page_number': 35} )$$ 

Page Content: $$( Food for thought.. 1. Given a list of numbers, how would you return a list of the square of each number? For example, given [1, 2, 3, 4, 5] you should return [1, 4, 9, 16, 25]. Answer: You can solve this problem by using map with a lambda that takes a number and returns the square of the number: List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); List<Integer> squares = numbers.stream0 (u * u <- u) deu. collect(toList()) ; 36  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 432, 'chunk_length': 432, 'page_number': 36} )$$ 

Page Content: $$( STREAMS: FINDING & MATCHING 37  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 31, 'chunk_length': 31, 'page_number': 37} )$$ 

Page Content: $$( Finding and matching Another common data processing idiom is finding whether some elements in a set of data match a given property. The Streams API provides such facilities through the allmatch, anyMatch, noneMatch, findFirst, and findAny methods of a stream. Checking to see if a predicate matches at least one element. if(menu.stream() .anyMatch(Dish::isVegetarian)) { The anyMatch method returns a boolean and is therefore a terminal operation  38  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 451, 'chunk_length': 451, 'page_number': 38} )$$ 

Page Content: $$( Checking to see if a predicate matches all elements The allMatch method works similarly to anyMatch but will check to see if all the ele- ments of the stream match the given predicate. For example, you can use it to find out whether the menu is healthy (all dishes are below 1000 calories): boolean isHealthy = menu.stream() .allmatch(dish -> dish.getCalories() < 1000) ; NONEMATCH The opposite of aliMatch is noneMatch. It ensures that no elements in the stream match the given predicate. For example, you could rewrite the previous example as follows using noneMatch: boolean isHealthy = menu.stream(). .noneMatch(d -> d.getcalories() >= 10o0); These three operations--- -anyMatch, allMatch, and noneMatch-. -make use of what we call short-circuiting, a stream version of the familiar Java short-circuiting && and I  39  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 822, 'chunk_length': 822, 'page_number': 39} )$$ 

Page Content: $$( the familiar Java short-circuiting && and I  39  )$$  
Metadata: $$( {'chunk_index': 1, 'start_position': 774, 'end_position': 822, 'chunk_length': 48, 'page_number': 39} )$$ 

Page Content: $$( findAny and findFirst... Reads.... findAny element and findFirst encounter of element. Optional<Dish> dish = menu.stream() .filter(Dish::isVegetarian. .findAny() ; Returns an menu.stream() Optional<Dish>. If a value is contained, .filter(Dish::isVegetarian). it's printed; otherwise .findAny() nothing happens. .ifPresent(dish -> System.out.println(dish.getName());  40  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 370, 'chunk_length': 370, 'page_number': 40} )$$ 

Page Content: $$( findAny and findFirst.... Reads.... findAny element and findFirst encounter of element List<Integer> someNumbers = Arrays.asList(1, 2, 3, 4, 5); Optional<Integer> firstSquareDivisibleByThree = someNumbers.stream() .map(n -> n * n) .filter(n -> n % 3 == 0) .findFirst(); // 9 When to use findFirst and findAny You may wonder why we have both findFirst and findAny. The answer is parallel- ism. Finding the first element is more constraining in parallel, If you don't care about. which element is returned, use findAny because it's less constraining when using parallel streams.. 41  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 581, 'chunk_length': 581, 'page_number': 41} )$$ 

Page Content: $$( Optional in a Nutshell The Optional<T> class (java.uti1.Optional) is a container class to represent the existence or absence of a value. In the previous code, it's possible that f indAny doesn't. find any element. Instead of returning null, which is well known for being error  isPresent () returns true if Optional contains a value, false otherwise. ifPresent (Consumer<T> block) executes the given block if a value is present. We introduced the Consumer functional interface in chapter 3; it lets you pass a. lambda that takes an argument of type T and returns void. T get() returns the value if present; otherwise it throws a NoSuchelement- Exception. T orElse(T other) returns the value if present; otherwise it returns a default value. 42  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 744, 'chunk_length': 744, 'page_number': 42} )$$ 

Page Content: $$( STREAMS: REDUCING 43  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 21, 'chunk_length': 21, 'page_number': 43} )$$ 

Page Content: $$( Summing the elements int sum = numbers.stream().reduce(0, (a, b) -> a + b); reduce takes two arguments: An initial value, here 0. A BinaryOperator<T> to combine two elements and produce a new value; here you use the lambda (a, b) -> a + b. int sum = numbers.stream().reduce(0, Integer::sum) ; How about multiplying all elements using reduce? 44  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 345, 'chunk_length': 345, 'page_number': 44} )$$ 

Page Content: $$( Numbers stream 3 9 Stream<Integer> reduce(0, (a, b) -> a + b) 0 12 Integer 21 45  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 81, 'chunk_length': 81, 'page_number': 45} )$$ 

Page Content: $$( No INITIAL VALUE There's also an overloaded variant of reduce that doesn't take an initial value, but it returns an Optional object Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b)); Maximum and minimum Optional<Integer> min = numbers.stream() .reduce(Integer::min) ; 46  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 288, 'chunk_length': 288, 'page_number': 46} )$$ 

Page Content: $$( Pop Quiz How would you count the number of dishes in a stream using the map and reduce methods? 47  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 99, 'chunk_length': 99, 'page_number': 47} )$$ 

Page Content: $$( Pop Quiz How would you count the number of dishes in a stream using the map and reduce methods? Answer: and then summing them using reduce! This is equivalent to counting, in order, the number of elements in the stream:. int count = menu.stream() .map(d -> 1) .reduce(0, (a, b) -> a + b) ; long count = menu.stream().count() ; 48  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 330, 'chunk_length': 330, 'page_number': 48} )$$ 

Page Content: $$( Type/functional Function Operation Type Return type interface used descriptor filter Intermediate Stream<T> Predicate<T> T -> boolean distinct Intermediate Stream<T> (stateful-unbounded) takeWhile Intermediate Stream<T> Predicate<T> T -> boolean dropWhile Intermediate Stream<T> Predicate<T> T -> boolean skip long Intermediate Stream<T> (stateful-bounded) limit Intermediate Stream<T> long (stateful-bounded) map Intermediate Stream<R> Function<T, R> T -> R flatMap Intermediate Stream<R> Function<T, T -> Stream<R> Stream<R>> sorted Intermediate Stream<T> Comparator<T> (T, T) ->int (stateful-unbounded) Terminal boolean Predicate<T> T -> boolean anyMatch Terminal  boolean noneMatch Predicate<T> T -> boolean 49  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 715, 'chunk_length': 715, 'page_number': 49} )$$ 

Page Content: $$( Type/functional Function Type Return type Operation interface used descriptor allmatch Terminal boolean Predicate<T> T -> boolean findAny Terminal Optional<T> findFirst Terminal Optional<T> forEach Terminal void Consumer<T> T -> void Terminal collect R Collector<T, A, R> reduce Terminal Optional<T> BinaryOperator<T> (T, T) -> T (stateful-bounded) Terminal long count 50  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 372, 'chunk_length': 372, 'page_number': 50} )$$ 

Page Content: $$( BUILDING STREAMS 51  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 20, 'chunk_length': 20, 'page_number': 51} )$$ 

Page Content: $$( Stream from values Stream<String> stream = Stream.of("Modern ", "Java ", "In ", "Action");. stream.map(String::toUpperCase) .forEach(System.out::println) ; You can get an empty stream using the empty method as follows:. Stream<String> emptyStream = Stream.empty() ;  52  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 270, 'chunk_length': 270, 'page_number': 52} )$$ 

Page Content: $$( Streams from arrays You can create a stream from an array using the static method Arrays. stream, which takes an array as parameter. For example, you can convert an array of primitive ints into an IntStream and then sum the IntStream to produce an int, as follows: int[] numbers = {2, 3, 5, 7, 11, 13}; The sum is 41. int sum = Arrays.stream(numbers).sum() ;  53  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 363, 'chunk_length': 363, 'page_number': 53} )$$ 

Page Content: $$( Streams from files (using the non-blocking Java's NIO API). Needto importjava.nio.file.Files. Streams are AutoCloseable so long uniqueWords = 0; there's no need for try-finally try(Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset())){ uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(" "))) Generates .distinct()  Removes a stream .count();  Counts the number duplicates of words of unique words catch(IOException e){ Deals with the exception if one { occurs when opening the file 54  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 528, 'chunk_length': 528, 'page_number': 54} )$$ 

Page Content: $$( COLLECTORS: OUICK PASS 55  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 26, 'chunk_length': 26, 'page_number': 55} )$$ 

Page Content: $$( Factory method Returned type Used to toList List<T> Gather all the stream's items in a List. Example use: List<Dish> dishes = menuStream. collect (toList () ) ; toSet Set<T> Gather all the stream's items in a Set, elimi-. nating duplicates. Example use: Set<Dish> dishes = menustream. collect(toSet () ) ; tocollection Collection<T> Gather all the stream's items in the collection. created by the provided supplier.. Example use: Collection<Dish> dishes = menustream.collect(tocollection(), ArrayList::new) ; counting Long Count the number of items in the stream... Example use: longhowManyDishes = menuStream. collect (counting () ) ; summingInt Integer Sum the values of an Integer property of the items in the stream. Example use: int totalcalories = menuStream. collect(summingInt(Dish: :getCalories)) ; averagingInt Double Calculate the average value of an Integer property of the items in the stream.. Example use: double avgCalories =. menuStream.collect (averagingInt(Dish::getCalories)) ;. summarizingInt IntSummary )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 1024, 'chunk_length': 1024, 'page_number': 56} )$$ 

Page Content: $$( summingInt(Dish: :getCalories)) ; averagingInt Double Calculate the average value of an Integer property of the items in the stream.. Example use: double avgCalories =. menuStream.collect (averagingInt(Dish::getCalories)) ;. summarizingInt IntSummaryStatistics. Collect statistics regarding an Integer prop erty of the items in the stream, such as the maximum, minimum, total, and average. Example use: IntSummaryStatistics menuStatistics =. menustream.collect(summarizingInt(Dish: :getCalories)) ;.  )$$  
Metadata: $$( {'chunk_index': 1, 'start_position': 774, 'end_position': 1274, 'chunk_length': 500, 'page_number': 56} )$$ 

Page Content: $$( Factory method  Returned type Used to joining String Concatenate the strings resulting from the invocation of the toString method on each item of the stream.. Example use: String shortMenu = menuStream.map(Dish::getName) .collect(joining(", ")) ; maxBy Optional<T> An Optiona1 wrapping the maximal element. in this stream according to the given compar- ator or Optional. empty() if the stream is empty. Example use: Optional<Dish> fattest = menuStream. collect (maxBy(comparingInt(Dish: :getCalories) )) ; minBy Optional<T> An Optiona1 wrapping the minimal element. in this stream according to the given compar- ator or Optional. empty() if the stream is empty. Example use: Optional<Dish> lightest = menuStream. collect(minBy(comparingInt(Dish: :getCalories) )) ; reducing The type produced by the. Reduce the stream to a single value starting reduction operation from an initial value used as accumulator and. iteratively combining it with each item of the stream using a BinaryOperator. Example use: int totalCalories = m )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 1024, 'chunk_length': 1024, 'page_number': 57} )$$ 

Page Content: $$( The type produced by the. Reduce the stream to a single value starting reduction operation from an initial value used as accumulator and. iteratively combining it with each item of the stream using a BinaryOperator. Example use: int totalCalories = menuStream.collect(reducing(o, Dish::getCalories, Integer::sum)) ; collectingAndThen The type returned by the.  Wrap another collector and apply a transfor- transforming function. mation function to its result. Example use: int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size)) ;  )$$  
Metadata: $$( {'chunk_index': 1, 'start_position': 774, 'end_position': 1329, 'chunk_length': 555, 'page_number': 57} )$$ 

Page Content: $$( Factory method Returned type Used to groupingBy Map<K, List<T>> Group the items in the stream based on the. value of one of their properties and use those. values as keys in the resulting Map. Example use: Map<Dish. Type, List<Dish>> dishesByType = menuStream.collect(groupingBy(Dish: :getType)) ; partitioningBy Map<Boolean, Partition the items in the stream based on the List<T>> result of the application of a predicate to each. of them. Example use: Map<Boolean, List<Dish>> vegetarianDishes = menuStream.collect(partitioningBy(Dish: :isVegetarian)) ; 58  )$$  
Metadata: $$( {'chunk_index': 0, 'start_position': 0, 'end_position': 559, 'chunk_length': 559, 'page_number': 58} )$$ 

